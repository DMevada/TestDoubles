{
    "docs": [
        {
            "location": "/", 
            "text": "TestDoubles - Light Weight Service Virtualization for iPaaS and Microservices\n\n\nIntroduction\n\n\nTestDoubles is a \"Test Double\" framework that mimics a service by acting as an intermediate agent between a client and the actual service. It can also act as a proxy and record the interactions between the client and the service. Once these interactions are recorded, they can be replayed to mimic the behavior of the actual service. Each service that is made by the tester or client is considered to be a test double. TestDoubles is intended to treat the middleware integration platforms such as MuleSoft, Oracle, Boomi, Informatica, JitterBit, SnapLogic and others as the \"System Under Test\", bringing the concept of Continuous Testing to the EAI world. The high level approach is described below.\n\n\n\n\nGetting Started\n\n\nInstalling TestDoubles\n\n\nDownload the from Dockerhub and run the container. It is preferable to run this from a dedicated terminal window.\n\n\n$ docker login -e=info@rahejas.org -u=cadevopsci -p=Welcome2CADevOpsCI!\n$ docker pull devopshub/testdoubles\n\n\n\n\nTo check the hostname and port in which TestDoubles is running\n\n\n\n\n\n\nIf Linux, hostname is \"localhost\"\n\n\n\n\n\n\nIf Darwin(Mac), Run '$ docker-machine ip default' and note down the IP-Address which is the hostname for Mac\n\n\n\n\n\n\nStart the testdoubles container using the following command and note down the port number it is returning. \n\n\n$ docker run -i -t --name testdoubles --net=host devopshub/testdoubles\n\n\n\n\nTo start the testdoubles in background and view the logs to notedown the hostname and port number\n\n\n$ docker run -d --name testdoubles --net=host devopshub/testdoubles\n$ docker logs -f testdoubles\n\n\n\n\nTo install the CLI on the test machine (test machine or middleware server) to access TestDoubles remotely.\n\n\nRun the curl command below with the hostname and port number noted down earlier. It describes the TestDoubles project and provide instructions for TestDoubles CLI installation.  \n\n\n$ curl -s http://\nhostname\n:\nPort\n\n\n\n\n\nCopy and run the curl command to execute install script with passing the TD_HOST(hostname and port number) for initial setup\n\n\ncurl -s http://\nhostname\n:\nPort\n/install.sh | TD_HOST=\nhttp://\nhostname\n:\nPort\n sh\n\nExample\ncurl -s http://localhost:5050/install.sh | TD_HOST=\nhttp://localhost:5050\n sh\n\n\n\n\nUsage\n\n\nUsing test doubles is done as follows by the tester of the System Under Test (SUT):\n\n\n\n\nCreate the test double\n\n\nSet the test double in recording mode\n\n\nUpdate the middleware system (SUT) to point the service to the test double instead of the real service\n\n\nSet the test double to stop the recording mode and get into playback mode\n\n\nSave the data and modify (optional) for future use\n\n\nRun the tests, which should bypass the real service and return responses from the test double\n\n\nAfter testing is complete, delete the test double, and update the SUT to point back to the real service\n\n\n\n\nNext Steps\n\n\n\n\nAPI Specification\n\n\nCLI Command Reference", 
            "title": "Home"
        }, 
        {
            "location": "/#testdoubles-light-weight-service-virtualization-for-ipaas-and-microservices", 
            "text": "", 
            "title": "TestDoubles - Light Weight Service Virtualization for iPaaS and Microservices"
        }, 
        {
            "location": "/#introduction", 
            "text": "TestDoubles is a \"Test Double\" framework that mimics a service by acting as an intermediate agent between a client and the actual service. It can also act as a proxy and record the interactions between the client and the service. Once these interactions are recorded, they can be replayed to mimic the behavior of the actual service. Each service that is made by the tester or client is considered to be a test double. TestDoubles is intended to treat the middleware integration platforms such as MuleSoft, Oracle, Boomi, Informatica, JitterBit, SnapLogic and others as the \"System Under Test\", bringing the concept of Continuous Testing to the EAI world. The high level approach is described below.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#getting-started", 
            "text": "Installing TestDoubles  Download the from Dockerhub and run the container. It is preferable to run this from a dedicated terminal window.  $ docker login -e=info@rahejas.org -u=cadevopsci -p=Welcome2CADevOpsCI!\n$ docker pull devopshub/testdoubles  To check the hostname and port in which TestDoubles is running    If Linux, hostname is \"localhost\"    If Darwin(Mac), Run '$ docker-machine ip default' and note down the IP-Address which is the hostname for Mac    Start the testdoubles container using the following command and note down the port number it is returning.   $ docker run -i -t --name testdoubles --net=host devopshub/testdoubles  To start the testdoubles in background and view the logs to notedown the hostname and port number  $ docker run -d --name testdoubles --net=host devopshub/testdoubles\n$ docker logs -f testdoubles  To install the CLI on the test machine (test machine or middleware server) to access TestDoubles remotely.  Run the curl command below with the hostname and port number noted down earlier. It describes the TestDoubles project and provide instructions for TestDoubles CLI installation.    $ curl -s http:// hostname : Port   Copy and run the curl command to execute install script with passing the TD_HOST(hostname and port number) for initial setup  curl -s http:// hostname : Port /install.sh | TD_HOST= http:// hostname : Port  sh\n\nExample\ncurl -s http://localhost:5050/install.sh | TD_HOST= http://localhost:5050  sh  Usage  Using test doubles is done as follows by the tester of the System Under Test (SUT):   Create the test double  Set the test double in recording mode  Update the middleware system (SUT) to point the service to the test double instead of the real service  Set the test double to stop the recording mode and get into playback mode  Save the data and modify (optional) for future use  Run the tests, which should bypass the real service and return responses from the test double  After testing is complete, delete the test double, and update the SUT to point back to the real service", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#next-steps", 
            "text": "API Specification  CLI Command Reference", 
            "title": "Next Steps"
        }, 
        {
            "location": "/CLI/", 
            "text": "TestDoubles CLI\n\n\nThe TestDoubles Command Line Interface is a unified tool to manage your TestDoubles services.\n\n\nSynopsis\n\n\ntd [options] [command] [parameters]\n\n\nOptions\n\n\n\n\nhelp\n\n\n\n\n\n\nLists all available TestDoubles commands and documentation reference.\n\n\n\n\nAvailable Commands\n\n\n\n\ncreate\n\n\nrecreate\n\n\nset-record-mode\n\n\nset-playback-mode\n\n\ndelete\n\n\ndescribe\n\n\n\n\ncreate\n\n\nCreates a new testdouble, or error if the testdouble already exists. There are two ways to create a testdouble. The necessary information for both ways is described below.\n\n\nSyntax\n\n\n\n\nCreate with testdouble name.\n\n\n\n\ntd [create] --td-name \ntestdoubleName\n \n\n\n\n\n--td-name {testdoubleName} (String)\n\n\n\n\nThe name of the testdouble to be created\n\n\n\n\n\n\nCreate with an existing file.\n\n\n\n\ntd [create] --file \nGoogle.json\n \n\n\n\n\n--file {file name} (String)\n\n\n\n\nThe JSON payload file for the testdouble to be created with absolute or relative path\n\n\n\n\nThe existing file must be in JSON format. An example JSON file is shown below.\n\n\n{\n    \nname\n: \ngoogleGeoPoints\n,\n    \nprotocol\n: \nhttp\n,\n    \nport\n: 5051,\n    \nstubs\n: []\n}\n\n\n\n\nExamples\n\n\nThis example specifies a new testdoubleName or the json payload file to create a new testdoubles instance\n\n\n$ td create --td-name \ngoogleGeoPoints\n\n$ td create --file \nGoogle.json\n\n\n\n\n\nOutput\n\n\nThe output displays the newly created testdouble parameters\n\n\nTestDoubles server listening at http://localhost:5050\n{\n    \nprotocol\n: \nhttp\n,\n    \nport\n: 52324,\n    \nname\n: \ngoogleGeoPoints\n,\n    \nrequests\n: [],\n    \nstubs\n: [],\n    \n_links\n: {\n        \nself\n: {\n            \nhref\n: \nhttp://localhost:2525/imposters/52324\n\n        }\n    },\n    \nhost\n: \nlocalhost\n\n}\n\n\n\n\nrecreate\n\n\nCreates more than one testdoubles with json file input, or error if any one of the testdouble already exists. If data already exists, all the testdouble will be created with the data.\n\n\nSyntax\n\n\nCreate multiple testdoubles with json payload\n\n\ntd [recreate] --file \nfileName\n \n\n\n\n\n--file {fileName} (String)\n\n\n\n\nThe json file with absolute or relative path\n\n\n\n\nExamples\n\n\nThis example creates multiple testdoubles passing the json payload file\n\n\n$ td recreate --file \nGoogle.json\n\n\n\n\n\nOutput\n\n\nThe output displays all the newly created testdoubles parameters and data, if passed it with the json file\n\n\n{\n  \nimposters\n: [\n    {\n      \nprotocol\n: \nhttp\n,\n      \nport\n: 49487,\n      \n_links\n: {\n        \nself\n: {\n          \nhref\n: \nhttp://localhost:2525/imposters/49487\n\n        }\n      }\n    },\n    {\n      \nprotocol\n: \nhttp\n,\n      \nport\n: 51469,\n      \n_links\n: {\n        \nself\n: {\n          \nhref\n: \nhttp://localhost:2525/imposters/51469\n\n        }\n      }\n    }\n  ]\n}\n\n\n\n\nset-record-mode\n\n\nCreates the testdouble, with a proxy endpoint so that the testdouble can mimic the actual end service. If the testdouble does not exist, an error response will be returned. Any data in the testdouble that exists will be replaced with the proxy definition.\n\n\nSyntax\n\n\ntd [set-record-mode] --td-name \ntestdoubleName\n --td-servicehost \ntestdoubles hostname\n\n\n\n\n\n--td-name {testDoubleName} (String)\n\n\n\n\nThe name of the testdouble instance \n\n\n\n\n--td-servicehost {testDoubles hostname} (String)\n\n\n\n\nThe hostname of the end service. \n\n\n\n\nExamples\n\n\nThis example creates a testdouble proxy endpoint for the testdouble instance\n\n\n$ td set-record-mode --td-name \ngoogleGeoPoints\n --td-servicehost \nhttps://maps.googleapis.com\n\n\n\n\n\nOutput\n\n\nThe output displays testdoubles proxy information\n\n\nTestDoubles server listening at http://localhost:5050\n{\n    \nprotocol\n: \nhttp\n,\n    \nport\n: 52324,\n    \nname\n: \ngoogleGeoPoints\n,\n    \nrequests\n: [],\n    \nstubs\n: [\n        {\n            \nresponses\n: [\n                {\n                    \nproxy\n: {\n                        \nto\n: \nhttps://maps.googleapis.com\n,\n                        \nmode\n: \nproxyAlways\n,\n                        \npredicateGenerators\n: [\n                            {\n                                \nmatches\n: {\n                                    \nmethod\n: true,\n                                    \npath\n: true,\n                                    \nquery\n: true\n                                }\n                            }\n                        ]\n                    }\n                }\n            ]\n        }\n    ],\n    \n_links\n: {\n        \nself\n: {\n            \nhref\n: \nhttp://localhost:2525/imposters/52324\n\n        }\n    },\n    \nhost\n: \nlocalhost\n\n}\n\n\n\n\nset-playback-mode\n\n\nRemoves the proxy for the existing testdouble, and saves any recorded data, replacing any previous data. Returns an error if the testdouble does not exist.\n\n\nSyntax\n\n\ntd [set-playback-mode] --td-name \ntestdoubleName\n\n\n\n\n\n--td-name {testDoubleName} (String)\n\n\n\n\nThe name of the testdouble instance created\n\n\n\n\nExamples\n\n\nThis example deletes the proxy endpoint created for the testdouble instance\n\n\n$ td set-playback-mode --td-name \ngoogleGeoPoints\n\n\n\n\n\nOutput\n\n\nThe output displays testdoubles recorded data \n\n\n{\n    \nprotocol\n: \nhttp\n,\n    \nport\n: 52324,\n    \nname\n: \ngoogleGeoPoints\n,\n    \nrequests\n: [],\n    \nstubs\n: [],\n    \n_links\n: {\n        \nself\n: {\n            \nhref\n: \nhttp://localhost:2525/imposters/52324\n\n        }\n    },\n    \nhost\n: \nlocalhost\n\n}\n\n\n\n\ndelete\n\n\nRemoves the proxy for the existing testdouble, and saves any recorded data, replacing any previous data. Returns an error if the testdouble does not exist.\n\n\nSyntax\n\n\n\n\nDelete all testdoubles created, if testdoubles name isn't specified\n\n\n\n\ntd [delete] \n\n\n\n\n\n\nDelete only the specified testdouble\n\n\n\n\ntd [delete] --td-name \ntestdoubleName\n\n\n\n\n\n--td-name {testDoubleName} (String)\n\n\n\n\nThe name of the testdouble to be deleted\n\n\n\n\nExamples\n\n\nThis example deletes either a single testdouble or all testdoubles created \n\n\n$ td delete\n$ td delete --td-name \ngoogleGeoPoints\n\n\n\n\n\nOutput\n\n\nThe output displays testdoubles recorded data, if recorded\n\n\n{\n    \nimposters\n: [\n        {\n            \nprotocol\n: \nhttp\n,\n            \nport\n: 56490,\n            \nname\n: \nGoogle\n,\n            \nstubs\n: []\n        },\n        {\n            \nprotocol\n: \nhttp\n,\n            \nport\n: 57646,\n            \nname\n: \nMaps\n,\n            \nstubs\n: []\n        }\n    ]\n}\n\n\n\n\ndescribe\n\n\nRetrieves all the testdoubles that currently exist, or error if no testdoubles exist. Does not return any recorded data.\n\n\nSyntax\n\n\n\n\nDescribes all the testdoubles created with the recorded data\n\n\n\n\ntd [describe]\n\n\n\n\n\n\nDescribes only the given testdoubles with the recorded data\n\n\n\n\ntd [describe] --td-name \ngooglegeopoints\n\n\n\n\n\n--td-name {testDoubleName} (String)\n\n\n\n\nThe name of the testdouble needed for the description\n\n\n\n\nExamples\n\n\nThis example displays either a single testdouble or multiple testdoubles recorded data\n\n\n$ td describe\n$ td describe --td-name \ngoogleGeoPoints\n\n\n\n\n\nOutput\n\n\nThe output displays all the testdoubles created\n\n\n{\n    \nimposters\n: [\n        {\n            \nprotocol\n: \nhttp\n,\n            \nport\n: 49487,\n            \nname\n: \nMaps\n,\n            \nstubs\n: []\n        },\n        {\n            \nprotocol\n: \nhttp\n,\n            \nport\n: 51469,\n            \nname\n: \nGoogle\n,\n            \nstubs\n: []\n        }\n    ]\n}", 
            "title": "CLI"
        }, 
        {
            "location": "/CLI/#testdoubles-cli", 
            "text": "The TestDoubles Command Line Interface is a unified tool to manage your TestDoubles services.", 
            "title": "TestDoubles CLI"
        }, 
        {
            "location": "/CLI/#synopsis", 
            "text": "td [options] [command] [parameters]", 
            "title": "Synopsis"
        }, 
        {
            "location": "/CLI/#options", 
            "text": "help    Lists all available TestDoubles commands and documentation reference.", 
            "title": "Options"
        }, 
        {
            "location": "/CLI/#available-commands", 
            "text": "create  recreate  set-record-mode  set-playback-mode  delete  describe   create  Creates a new testdouble, or error if the testdouble already exists. There are two ways to create a testdouble. The necessary information for both ways is described below.  Syntax   Create with testdouble name.   td [create] --td-name  testdoubleName    --td-name {testdoubleName} (String)   The name of the testdouble to be created    Create with an existing file.   td [create] --file  Google.json    --file {file name} (String)   The JSON payload file for the testdouble to be created with absolute or relative path   The existing file must be in JSON format. An example JSON file is shown below.  {\n     name :  googleGeoPoints ,\n     protocol :  http ,\n     port : 5051,\n     stubs : []\n}  Examples  This example specifies a new testdoubleName or the json payload file to create a new testdoubles instance  $ td create --td-name  googleGeoPoints \n$ td create --file  Google.json   Output  The output displays the newly created testdouble parameters  TestDoubles server listening at http://localhost:5050\n{\n     protocol :  http ,\n     port : 52324,\n     name :  googleGeoPoints ,\n     requests : [],\n     stubs : [],\n     _links : {\n         self : {\n             href :  http://localhost:2525/imposters/52324 \n        }\n    },\n     host :  localhost \n}  recreate  Creates more than one testdoubles with json file input, or error if any one of the testdouble already exists. If data already exists, all the testdouble will be created with the data.  Syntax  Create multiple testdoubles with json payload  td [recreate] --file  fileName    --file {fileName} (String)   The json file with absolute or relative path   Examples  This example creates multiple testdoubles passing the json payload file  $ td recreate --file  Google.json   Output  The output displays all the newly created testdoubles parameters and data, if passed it with the json file  {\n   imposters : [\n    {\n       protocol :  http ,\n       port : 49487,\n       _links : {\n         self : {\n           href :  http://localhost:2525/imposters/49487 \n        }\n      }\n    },\n    {\n       protocol :  http ,\n       port : 51469,\n       _links : {\n         self : {\n           href :  http://localhost:2525/imposters/51469 \n        }\n      }\n    }\n  ]\n}  set-record-mode  Creates the testdouble, with a proxy endpoint so that the testdouble can mimic the actual end service. If the testdouble does not exist, an error response will be returned. Any data in the testdouble that exists will be replaced with the proxy definition.  Syntax  td [set-record-mode] --td-name  testdoubleName  --td-servicehost  testdoubles hostname   --td-name {testDoubleName} (String)   The name of the testdouble instance    --td-servicehost {testDoubles hostname} (String)   The hostname of the end service.    Examples  This example creates a testdouble proxy endpoint for the testdouble instance  $ td set-record-mode --td-name  googleGeoPoints  --td-servicehost  https://maps.googleapis.com   Output  The output displays testdoubles proxy information  TestDoubles server listening at http://localhost:5050\n{\n     protocol :  http ,\n     port : 52324,\n     name :  googleGeoPoints ,\n     requests : [],\n     stubs : [\n        {\n             responses : [\n                {\n                     proxy : {\n                         to :  https://maps.googleapis.com ,\n                         mode :  proxyAlways ,\n                         predicateGenerators : [\n                            {\n                                 matches : {\n                                     method : true,\n                                     path : true,\n                                     query : true\n                                }\n                            }\n                        ]\n                    }\n                }\n            ]\n        }\n    ],\n     _links : {\n         self : {\n             href :  http://localhost:2525/imposters/52324 \n        }\n    },\n     host :  localhost \n}  set-playback-mode  Removes the proxy for the existing testdouble, and saves any recorded data, replacing any previous data. Returns an error if the testdouble does not exist.  Syntax  td [set-playback-mode] --td-name  testdoubleName   --td-name {testDoubleName} (String)   The name of the testdouble instance created   Examples  This example deletes the proxy endpoint created for the testdouble instance  $ td set-playback-mode --td-name  googleGeoPoints   Output  The output displays testdoubles recorded data   {\n     protocol :  http ,\n     port : 52324,\n     name :  googleGeoPoints ,\n     requests : [],\n     stubs : [],\n     _links : {\n         self : {\n             href :  http://localhost:2525/imposters/52324 \n        }\n    },\n     host :  localhost \n}  delete  Removes the proxy for the existing testdouble, and saves any recorded data, replacing any previous data. Returns an error if the testdouble does not exist.  Syntax   Delete all testdoubles created, if testdoubles name isn't specified   td [delete]    Delete only the specified testdouble   td [delete] --td-name  testdoubleName   --td-name {testDoubleName} (String)   The name of the testdouble to be deleted   Examples  This example deletes either a single testdouble or all testdoubles created   $ td delete\n$ td delete --td-name  googleGeoPoints   Output  The output displays testdoubles recorded data, if recorded  {\n     imposters : [\n        {\n             protocol :  http ,\n             port : 56490,\n             name :  Google ,\n             stubs : []\n        },\n        {\n             protocol :  http ,\n             port : 57646,\n             name :  Maps ,\n             stubs : []\n        }\n    ]\n}  describe  Retrieves all the testdoubles that currently exist, or error if no testdoubles exist. Does not return any recorded data.  Syntax   Describes all the testdoubles created with the recorded data   td [describe]   Describes only the given testdoubles with the recorded data   td [describe] --td-name  googlegeopoints   --td-name {testDoubleName} (String)   The name of the testdouble needed for the description   Examples  This example displays either a single testdouble or multiple testdoubles recorded data  $ td describe\n$ td describe --td-name  googleGeoPoints   Output  The output displays all the testdoubles created  {\n     imposters : [\n        {\n             protocol :  http ,\n             port : 49487,\n             name :  Maps ,\n             stubs : []\n        },\n        {\n             protocol :  http ,\n             port : 51469,\n             name :  Google ,\n             stubs : []\n        }\n    ]\n}", 
            "title": "Available Commands"
        }, 
        {
            "location": "/API/", 
            "text": "TestDoubles API\n\n\nThe REST API provides a programmatic approach to access TestDoubles features.\n\n\nThe \"{}\" denotes that an appropriate value must be substituted for the required parameter, for the api path only.\n\n\n\n\nGET /testdoubles\n\n\nGET /testdoubles/{testDoubleName}\n\n\nPOST /testdoubles\n\n\nPOST /testdoubles/{testDoubleName}/proxy\n\n\nPOST /testdouble/{testDoubleName}\n\n\nDELETE /testdoubles/{testDoubleName}/proxy\n\n\nDELETE /testdoubles\n\n\nDELETE /testdoubles/{testDoubleName}\n\n\nPUT /testdoubles\n\n\n\n\nGET /testdoubles\n\n\n\n\nRetrieves all the testdoubles that currently exist, or error if no testdoubles exist. Does not return any recorded data.\n\n\n\n\nThere is no JSON payload for this API.\n\n\nCURL example\n\n\ncurl -X GET http://hostname:port/testdoubles\n\n\n\n\nGET /testdoubles/{testDoubleName}\n\n\n\n\nRetrieves a testdouble, or error if the testdouble does not exist.\n\n\n\n\nThere is no JSON payload for this API.\n\n\nCURL example\n\n\ncurl -X GET http://hostname:post/testdoubles/{testDoubleName}\n\n\n\n\nPOST /testdoubles\n\n\n\n\nCreates a new testdouble, or error if the testdouble already exists. \n\n\n\n\nRequired parameters\n\n\n\n\ntestDoubleName: The name of the testdouble.\n\n\n\n\nJSON example\n\n\n{\n    \nname\n: \ngoogle\n,\n    \nprotocol\n: \nhttp\n\n}\n\n\n\n\nCURL example with regular JSON data\n\n\ncurl -X POST -H 'Content-Type: application/json' -d '{\nname\n: \ngoogle\n, \nprotocol\n: \nhttp\n}' http://hostname:port/testdoubles\n\n\n\n\nCURL example with JSON file\n\n\ncurl -X POST -H 'Content-Type: application/json' --data @\npath/to/file\n http://hostname:port/testdoubles\n\n\n\n\nPOST /testdoubles/{testDoubleName}/proxy\n\n\n\n\nCreates the testdouble, but with a proxy endpoint so that the testdouble can mimic the end service.\nIf the testdouble does not exist, an error response will be returned.\nAny data in the testdouble that exists will be replaced with the proxy definition.\n\n\n\n\nRequired parameters\n\n\n\n\ntestDoubleName: The name of the testdouble.\n\n\nserviceHost: the hostname of the end service. Must be passed as a JSON payload.\n\n\n\n\nJSON Example\n\n\n{\n    \nserviceHost\n: \nhttp://maps.googleapis.com\n\n}\n\n\n\n\nCURL example\n\n\ncurl -X POST -H 'Content-Type: application/json' -d'{\n    \nserviceHost\n: \nhttps://api.stackexchange.com\n\n}' http://hostname:port/testdoubles/{testDoubleName}/proxy\n\n\n\n\nPOST /testdoubles/{testDoubleName}\n\n\n\n\nCreates a testdouble with the specified data after converting it into the required format.\n\n\n\n\nRequired parameter\n\n\n\n\ntestDouble name: The name of the testdouble\n\n\nFile: The file containing the data\n\n\nFormat of the file: The type of data\n\n\n\n\nOptions 2 and 3 must be sent through the payload.\n\n\nDELETE /testdoubles/{testDoubleName}/proxy\n\n\n\n\nRemoves the proxy for the existing testdouble, and saves any recorded data, replacing any previous data.\nReturns an error if the testdouble does not exist.\n\n\n\n\nThere is no JSON payload for this API.\n\n\nRequired parameter\n\n\n\n\ntestDoubleName: The name of the test double\n\n\n\n\nCURL example\n\n\ncurl -X DELETE http://hostname:port/testdoubles/{testDoubleName}/proxy\n\n\n\n\nDELETE /testdoubles\n\n\n\n\nDeletes all testdoubles.\n\n\n\n\nThere is no JSON payload for this API.\n\n\nCURL example\n\n\ncurl -X DELETE http://hostname:port/testdoubles\n\n\n\n\nDELETE /testdoubles/{testDoubleName}\n\n\n\n\nDeletes a testdouble.\n\n\n\n\nThere is no JSON payload for this API.\n\n\nRequired parameter\n\n\n\n\ntestDoubleName: The name of the testdouble.\n\n\n\n\nCURL example\n\n\ncurl -X DELETE http://hostname:port/testdoubles/{testDoubleName}\n\n\n\n\nPUT /testdoubles\n\n\n\n\nImports a list of testdoubles.\n\n\n\n\nJSON payload example\n\n\n{\n    \nimposters\n: [\n        {\n            \nname\n: \ngoogle\n,\n            \nprotocol\n: \nhttp\n,\n            \nrequests\n: [],\n            \nstubs\n: []\n        },\n        {\n            \nname\n: \ntest\n,\n            \nprotocol\n: \nhttp\n,\n            \nrequests\n: [],\n            \nstubs\n: []\n        }\n    ]\n}\n\n\n\n\nRequired parameter\n\n\nThe parameter must be passed as a JSON payload, as shown above. Each element in the imposters array represents a testdouble.\nEach testdouble must have a name at a minimum, otherwise the entire operation will be rejected.\n\n\nCURL example with file\n\n\ncurl -X PUT -H ${header} --data @\npath/to/file/here\n http://hostname:port/testdoubles", 
            "title": "API"
        }, 
        {
            "location": "/API/#testdoubles-api", 
            "text": "The REST API provides a programmatic approach to access TestDoubles features.  The \"{}\" denotes that an appropriate value must be substituted for the required parameter, for the api path only.   GET /testdoubles  GET /testdoubles/{testDoubleName}  POST /testdoubles  POST /testdoubles/{testDoubleName}/proxy  POST /testdouble/{testDoubleName}  DELETE /testdoubles/{testDoubleName}/proxy  DELETE /testdoubles  DELETE /testdoubles/{testDoubleName}  PUT /testdoubles", 
            "title": "TestDoubles API"
        }, 
        {
            "location": "/API/#get-testdoubles", 
            "text": "Retrieves all the testdoubles that currently exist, or error if no testdoubles exist. Does not return any recorded data.   There is no JSON payload for this API.  CURL example  curl -X GET http://hostname:port/testdoubles", 
            "title": "GET /testdoubles"
        }, 
        {
            "location": "/API/#get-testdoublestestdoublename", 
            "text": "Retrieves a testdouble, or error if the testdouble does not exist.   There is no JSON payload for this API.  CURL example  curl -X GET http://hostname:post/testdoubles/{testDoubleName}", 
            "title": "GET /testdoubles/{testDoubleName}"
        }, 
        {
            "location": "/API/#post-testdoubles", 
            "text": "Creates a new testdouble, or error if the testdouble already exists.    Required parameters   testDoubleName: The name of the testdouble.   JSON example  {\n     name :  google ,\n     protocol :  http \n}  CURL example with regular JSON data  curl -X POST -H 'Content-Type: application/json' -d '{ name :  google ,  protocol :  http }' http://hostname:port/testdoubles  CURL example with JSON file  curl -X POST -H 'Content-Type: application/json' --data @ path/to/file  http://hostname:port/testdoubles", 
            "title": "POST /testdoubles"
        }, 
        {
            "location": "/API/#post-testdoublestestdoublenameproxy", 
            "text": "Creates the testdouble, but with a proxy endpoint so that the testdouble can mimic the end service.\nIf the testdouble does not exist, an error response will be returned.\nAny data in the testdouble that exists will be replaced with the proxy definition.   Required parameters   testDoubleName: The name of the testdouble.  serviceHost: the hostname of the end service. Must be passed as a JSON payload.   JSON Example  {\n     serviceHost :  http://maps.googleapis.com \n}  CURL example  curl -X POST -H 'Content-Type: application/json' -d'{\n     serviceHost :  https://api.stackexchange.com \n}' http://hostname:port/testdoubles/{testDoubleName}/proxy", 
            "title": "POST /testdoubles/{testDoubleName}/proxy"
        }, 
        {
            "location": "/API/#post-testdoublestestdoublename", 
            "text": "Creates a testdouble with the specified data after converting it into the required format.   Required parameter   testDouble name: The name of the testdouble  File: The file containing the data  Format of the file: The type of data   Options 2 and 3 must be sent through the payload.", 
            "title": "POST /testdoubles/{testDoubleName}"
        }, 
        {
            "location": "/API/#delete-testdoublestestdoublenameproxy", 
            "text": "Removes the proxy for the existing testdouble, and saves any recorded data, replacing any previous data.\nReturns an error if the testdouble does not exist.   There is no JSON payload for this API.  Required parameter   testDoubleName: The name of the test double   CURL example  curl -X DELETE http://hostname:port/testdoubles/{testDoubleName}/proxy", 
            "title": "DELETE /testdoubles/{testDoubleName}/proxy"
        }, 
        {
            "location": "/API/#delete-testdoubles", 
            "text": "Deletes all testdoubles.   There is no JSON payload for this API.  CURL example  curl -X DELETE http://hostname:port/testdoubles", 
            "title": "DELETE /testdoubles"
        }, 
        {
            "location": "/API/#delete-testdoublestestdoublename", 
            "text": "Deletes a testdouble.   There is no JSON payload for this API.  Required parameter   testDoubleName: The name of the testdouble.   CURL example  curl -X DELETE http://hostname:port/testdoubles/{testDoubleName}", 
            "title": "DELETE /testdoubles/{testDoubleName}"
        }, 
        {
            "location": "/API/#put-testdoubles", 
            "text": "Imports a list of testdoubles.   JSON payload example  {\n     imposters : [\n        {\n             name :  google ,\n             protocol :  http ,\n             requests : [],\n             stubs : []\n        },\n        {\n             name :  test ,\n             protocol :  http ,\n             requests : [],\n             stubs : []\n        }\n    ]\n}  Required parameter  The parameter must be passed as a JSON payload, as shown above. Each element in the imposters array represents a testdouble.\nEach testdouble must have a name at a minimum, otherwise the entire operation will be rejected.  CURL example with file  curl -X PUT -H ${header} --data @ path/to/file/here  http://hostname:port/testdoubles", 
            "title": "PUT /testdoubles"
        }, 
        {
            "location": "/implementation_details/", 
            "text": "Implementation Details\n\n\nTech Stack\n\n\n\n\nNodeJS: Server side Javascript framework.\n\n\nHapiJS: Web framework for building RESTful APIs in Javascript.\n\n\nlog4js: A NodeJS logging library. \n\n\nMocha: Testing framework for JavaScript.\n\n\nChai: Assertion library.\n\n\n\n\nRequest Lifecycle\n\n\nWhen a request is first made by the client, it is handled by the HapiJS router. The routes are defined in the routes file, inside src/. The routes file is structured such that each API is handled by a separate controller. The routes file also has access to the handlers of every API. Each API is uniquely defined by the following:\n\n\n\n\nmethod (GET, POST, PUT, DELETE, etc.)\n\n\npath (/, /testdoubles, /testdoubles/{testDoubleName}, etc.)\n\n\nhandler (A function that resides in a separate controller file that contains the logic to handle the request.)\n\n\n\n\nThe ratio of routes to controllers to tests is 1:1:1. This means that each route defined in the routes file corresponds to a single controller, which in turn corresponds to a single test file. After a request is sent to the route, it is then handled by the appropriate controller. Once the controller finishes executing its logic, it will then call a specific function inside the requests file. The requests file is also inside src/, and is responsible for making all HTTP requests to the underlying Mountebank API. \n\n\nEach function in the requests file, although independent, relies on other functions as its callback. The reason callbacks are used in because Node's HTTP request methods are asynchronous. As a result, the code that is meant to be executed after the asynchronous HTTP request is made must reside in the callback function. In some functions, the callback is an anonymous function because it is easier to execute in-line. Also, all the functions that make the HTTP request in the requests.js file contain only two parameters. The first is the testDoubleDefinition, and the second is the reply object. \n\n\nIt can be argued that Node's HTTP request library is verbose in comparison to other open-source libraries such as request, restify, unirest, and others which perform the same task in fewer lines of code. However, Node's standard library is used here because it is well-tested and reliable. In the test folder, Node's HTTP library is not used because its verbosity is a drawback. As a result, all tests are written using the request library to make HTTP requests to the Testdoubles API.\n\n\nOnce the request is handled, a reply response is sent back to the client from the Hapi webserver. If the reply object is not passed to the function in the requests.js file, an internal server error will be generated by Hapi.\n\n\nLogger and Utils\n\n\nThe logger.js and the utils.js file are also vital for the execution of the application. The logger contains the configuration to setup a logger object, which is then used by the utils file. Each file that imports the utils file also subsequently imports the logger. The log level is implemented by reading the NODE_ENV environment variable. If it is not set, it will be defaulted to \"development\". As a result, if the value of the env variable is \"development\" the log level will be set to debug. For all other values, the log level will be set to info. The log file is inside the logs/ folder. \n\n\nThe utils file contains all the functions that are commonly used by most controllers. This includes file checking, writing to files, deleting files, and retrieving the testdouble object.\n\n\nTestdoubles\n\n\nEach testdouble has a testDoubleName.json file, where testDoubleName is the name of the testdouble. This file houses\nthe definition of the testdouble. All testdouble definitions are stored in the testdoubles/ directory.\n\n\nA JSON example for a testdouble's definition file is given below.\n\n\n{\n    protocol: \nhttp\n,\n    name: \ngoogle\n,\n    port: 5051,\n    stubs: [\n      {\n        responses: [\n          {\n            proxy: {\n              to: \nhttp://maps.googleapis.com\n,\n              mode: \nproxyAlways\n,\n              predicateGenerators: [{\n                matches: {\n                  method: true,\n                  path: true,\n                  query: true                   \n              }\n            }]\n          }\n        }\n      ]\n    }\n  ]\n}\n\n\n\n\nThe above example describes a testdouble that contains a proxy to the Google Maps API. \n\n\n12 Factor Application\n\n\nA well-designed and programmed application generally follows the 12 factors standard for the SaaS model.\nThe TestDoubles software is evaluated for each of the 12 factors below.\n\n\n\n\n\n\nCodebase\n\n\n\n\nCodebase refers to having one repository in which the code is tracked. Each deployment of the code is still considered the same codebase. TestDoubles is compliant with this factor, as all code is stored in this repo.\n\n\n\n\n\n\n\n\nDependencies\n\n\n\n\nHave all dependencies (modules or other programs that the software relies on), present in a local manner. That is, there are no dependencies on what the underlying OS provides. TestDoubles is mostly compliant with this factor. TestDoubles relies on curl as a system-wide dependency, but all other dependencies can be installed using npm install.\n\n\n\n\n\n\n\n\nConfig\n\n\n\n\nConfiguration in the code should never be hard-coded, but rather important values should be stored in environment variables. TestDoubles is compliant with this factor.\n\n\n\n\n\n\n\n\nBacking Services\n\n\n\n\nEach local resource or a third party resource should be treated alike, so that resources can be replaced easily if necessary in the future. TestDoubles is compliant with this factor. \n\n\n\n\n\n\n\n\nBuild, release, run\n\n\n\n\nThe processes of building, releasing and running must be separate. TestDoubles is compliant with this factor because it has a Makefile which houses separate commands for each of the above processes. Building a docker container is done with one command, release (to DockerHub) is done with another command, and finally the run is also another command.\n\n\n\n\n\n\n\n\nProcesses\n\n\n\n\nThe execution of the software must be a single process, and also the software must be stateless. TestDoubles is not compliant with this factor.\n\n\n\n\n\n\n\n\nPort Binding\n\n\n\n\nThe application is self-contained and incoming requests are handled by an external entity that will route the request to the specified port. TestDoubles is compliant with this factor.\n\n\n\n\n\n\n\n\nConcurrency\n\n\n\n\nThere should be different process types and each process type should handle the necessary operation accordingly. TestDoubles is not compliant with this factor because it creates a pid file for each instance of the TestDouble.\n\n\n\n\n\n\n\n\nDisposability\n\n\n\n\nThe application and its processes should be disposable, and they should be quick to start up. TestDoubles is compliant with this factor because it starts within seconds, and also shuts down gracefully.\n\n\n\n\n\n\n\n\nDev/Prod parity\n\n\n\n\nThere should be almost no distinction between the Dev and Prod environments. Builds should occur quickly and there should be no inconsistencies. TestDoubles is compliant with this factor.\n\n\n\n\n\n\n\n\nLogs\n\n\n\n\nLogs should be gathered in a single location for viewing and archiving. TestDoubles is compliant with this factor.\n\n\n\n\n\n\n\n\nAdmin Processes\n\n\n\n\nAdmin code should be the same as production code, and must ship with it. Dependency isolation and other factors also apply. TestDoubles is compliant with this factor.\n\n\n\n\n\n\n\n\nScalability\n\n\nThere are two options for scalability. The first is to embed MB inside of TD, and the second is to separate MB from TD.\nIrrespective of the option, there is always a TD registry file that maintains a lookup of the testdoubles that exist on each node. The registry file is maintained by Consul. Each instance of TD runs inside a docker container. A node can have many docker containers, and each node must also have a docker container for Registrator. Registrator is a third party service that automatically registers and deregisters a service with Consul. Consul should be on its own node, and not in a docker container. \n\n\nThere are two main problems for scalability: service discovery and service registration. \n\n\nService Discovery\n\n\nThere are two possible solutions to service discovery - client side discovery and server side discovery. \nClient side discovery queries the service registry and the client uses a loadbalancing algorithm to choose the service and route accordingly.\n\n\nPros \n\n\n\n\nClient can make its own decisions regarding routing to the correct service\n\n\n\n\nCons\n\n\n\n\nClient code must have logic to select a service, and this is an overhead because it unnecessarily combines the client with the service.\n\n\n\n\nServer side service discovery relies on the loadbalancer to query the service registry and then route the client request accordingly. \n\n\nPros \n\n\n\n\nClient is not responsible for discovery\n\n\n\n\nCon\n\n\n\n\nNeed to maintain one more component\n\n\n\n\nService Registration\n\n\nThere are two possible solutions for service registration: self registration and third party registration.\n\n\nSelf registration (and deregistration) requires the service to register with Consul, using either the Consul HTTP API or DNS API. \n\n\nPros\n\n\n\n\nNo third party application required\n\n\n\n\nCons\n\n\n\n\nApplication will have to register itself\n\n\n\n\nThird party registration requires another component called a service registrar to register the service. In this case, an application called Registrator can automatically register a service to Consul.\n\n\nPros\n\n\n\n\nAutomatic, because the application does not have to handle the registration\n\n\n\n\nCons\n\n\n\n\nOne more component dependency\n\n\n\n\nTD Registry File Structure\n\n\nThe TD registry file essentially contains key value pairs that map the TD host to a testdouble. If an entry doesn't exist, it means that the testdouble does not exist. The TD registry file should be updated only for the APIs shown below.\n\n\n1. POST /testdoubles\n2. PUT /testdoubles\n3. DELETE /testdoubles/{testDoubleName}\n4. DELETE /testdoubles\n\n\n\nThe existence of a testdouble is determined by whether the testdouble with provided name exists in the lookup file. \n\n\nEmbed MB inside of TD\n\n\nCons \n\n\n\n\nLack of control between TD and MB, because MB is embedded inside of TD.\n\n\nTD remains stateful\n\n\nDisposing of TD also disposes of MB\n\n\n\n\nPros\n\n\n\n\nThere is only one registry file and that is the TD registry file. \n\n\nAll HTTP requests will be made to localhost, so there is no need to make changes to any code that makes HTTP requests.\n\n\n\n\nSeparate MB from TD\n\n\nCons\n\n\n\n\nCode that makes HTTP requests will have to be changed to dynamically make a request to the particular host.\n\n\ntdctl file have to be changed, because MB is no longer imported. This has a cascading effect because MB and TD must be started separately.\n\n\nIf MB is unavailable, it must be restarted separately from TD. \n\n\nRequires more nodes (either physical or virtual).\n\n\nRequires one more environment variable, MB_HOST.\n\n\n\n\nPros\n\n\n\n\nTD becomes stateless, as all state is now maintained in MB, thus achieving disposability.\n\n\nAllows for greater control of TD, and with this, implemeting SIGTERM and SIGINT behavior is possible.", 
            "title": "Implementation"
        }, 
        {
            "location": "/implementation_details/#implementation-details", 
            "text": "", 
            "title": "Implementation Details"
        }, 
        {
            "location": "/implementation_details/#tech-stack", 
            "text": "NodeJS: Server side Javascript framework.  HapiJS: Web framework for building RESTful APIs in Javascript.  log4js: A NodeJS logging library.   Mocha: Testing framework for JavaScript.  Chai: Assertion library.", 
            "title": "Tech Stack"
        }, 
        {
            "location": "/implementation_details/#request-lifecycle", 
            "text": "When a request is first made by the client, it is handled by the HapiJS router. The routes are defined in the routes file, inside src/. The routes file is structured such that each API is handled by a separate controller. The routes file also has access to the handlers of every API. Each API is uniquely defined by the following:   method (GET, POST, PUT, DELETE, etc.)  path (/, /testdoubles, /testdoubles/{testDoubleName}, etc.)  handler (A function that resides in a separate controller file that contains the logic to handle the request.)   The ratio of routes to controllers to tests is 1:1:1. This means that each route defined in the routes file corresponds to a single controller, which in turn corresponds to a single test file. After a request is sent to the route, it is then handled by the appropriate controller. Once the controller finishes executing its logic, it will then call a specific function inside the requests file. The requests file is also inside src/, and is responsible for making all HTTP requests to the underlying Mountebank API.   Each function in the requests file, although independent, relies on other functions as its callback. The reason callbacks are used in because Node's HTTP request methods are asynchronous. As a result, the code that is meant to be executed after the asynchronous HTTP request is made must reside in the callback function. In some functions, the callback is an anonymous function because it is easier to execute in-line. Also, all the functions that make the HTTP request in the requests.js file contain only two parameters. The first is the testDoubleDefinition, and the second is the reply object.   It can be argued that Node's HTTP request library is verbose in comparison to other open-source libraries such as request, restify, unirest, and others which perform the same task in fewer lines of code. However, Node's standard library is used here because it is well-tested and reliable. In the test folder, Node's HTTP library is not used because its verbosity is a drawback. As a result, all tests are written using the request library to make HTTP requests to the Testdoubles API.  Once the request is handled, a reply response is sent back to the client from the Hapi webserver. If the reply object is not passed to the function in the requests.js file, an internal server error will be generated by Hapi.", 
            "title": "Request Lifecycle"
        }, 
        {
            "location": "/implementation_details/#logger-and-utils", 
            "text": "The logger.js and the utils.js file are also vital for the execution of the application. The logger contains the configuration to setup a logger object, which is then used by the utils file. Each file that imports the utils file also subsequently imports the logger. The log level is implemented by reading the NODE_ENV environment variable. If it is not set, it will be defaulted to \"development\". As a result, if the value of the env variable is \"development\" the log level will be set to debug. For all other values, the log level will be set to info. The log file is inside the logs/ folder.   The utils file contains all the functions that are commonly used by most controllers. This includes file checking, writing to files, deleting files, and retrieving the testdouble object.", 
            "title": "Logger and Utils"
        }, 
        {
            "location": "/implementation_details/#testdoubles", 
            "text": "Each testdouble has a testDoubleName.json file, where testDoubleName is the name of the testdouble. This file houses\nthe definition of the testdouble. All testdouble definitions are stored in the testdoubles/ directory.  A JSON example for a testdouble's definition file is given below.  {\n    protocol:  http ,\n    name:  google ,\n    port: 5051,\n    stubs: [\n      {\n        responses: [\n          {\n            proxy: {\n              to:  http://maps.googleapis.com ,\n              mode:  proxyAlways ,\n              predicateGenerators: [{\n                matches: {\n                  method: true,\n                  path: true,\n                  query: true                   \n              }\n            }]\n          }\n        }\n      ]\n    }\n  ]\n}  The above example describes a testdouble that contains a proxy to the Google Maps API.", 
            "title": "Testdoubles"
        }, 
        {
            "location": "/implementation_details/#12-factor-application", 
            "text": "A well-designed and programmed application generally follows the 12 factors standard for the SaaS model.\nThe TestDoubles software is evaluated for each of the 12 factors below.    Codebase   Codebase refers to having one repository in which the code is tracked. Each deployment of the code is still considered the same codebase. TestDoubles is compliant with this factor, as all code is stored in this repo.     Dependencies   Have all dependencies (modules or other programs that the software relies on), present in a local manner. That is, there are no dependencies on what the underlying OS provides. TestDoubles is mostly compliant with this factor. TestDoubles relies on curl as a system-wide dependency, but all other dependencies can be installed using npm install.     Config   Configuration in the code should never be hard-coded, but rather important values should be stored in environment variables. TestDoubles is compliant with this factor.     Backing Services   Each local resource or a third party resource should be treated alike, so that resources can be replaced easily if necessary in the future. TestDoubles is compliant with this factor.      Build, release, run   The processes of building, releasing and running must be separate. TestDoubles is compliant with this factor because it has a Makefile which houses separate commands for each of the above processes. Building a docker container is done with one command, release (to DockerHub) is done with another command, and finally the run is also another command.     Processes   The execution of the software must be a single process, and also the software must be stateless. TestDoubles is not compliant with this factor.     Port Binding   The application is self-contained and incoming requests are handled by an external entity that will route the request to the specified port. TestDoubles is compliant with this factor.     Concurrency   There should be different process types and each process type should handle the necessary operation accordingly. TestDoubles is not compliant with this factor because it creates a pid file for each instance of the TestDouble.     Disposability   The application and its processes should be disposable, and they should be quick to start up. TestDoubles is compliant with this factor because it starts within seconds, and also shuts down gracefully.     Dev/Prod parity   There should be almost no distinction between the Dev and Prod environments. Builds should occur quickly and there should be no inconsistencies. TestDoubles is compliant with this factor.     Logs   Logs should be gathered in a single location for viewing and archiving. TestDoubles is compliant with this factor.     Admin Processes   Admin code should be the same as production code, and must ship with it. Dependency isolation and other factors also apply. TestDoubles is compliant with this factor.", 
            "title": "12 Factor Application"
        }, 
        {
            "location": "/implementation_details/#scalability", 
            "text": "There are two options for scalability. The first is to embed MB inside of TD, and the second is to separate MB from TD.\nIrrespective of the option, there is always a TD registry file that maintains a lookup of the testdoubles that exist on each node. The registry file is maintained by Consul. Each instance of TD runs inside a docker container. A node can have many docker containers, and each node must also have a docker container for Registrator. Registrator is a third party service that automatically registers and deregisters a service with Consul. Consul should be on its own node, and not in a docker container.   There are two main problems for scalability: service discovery and service registration.", 
            "title": "Scalability"
        }, 
        {
            "location": "/implementation_details/#service-discovery", 
            "text": "There are two possible solutions to service discovery - client side discovery and server side discovery. \nClient side discovery queries the service registry and the client uses a loadbalancing algorithm to choose the service and route accordingly.  Pros    Client can make its own decisions regarding routing to the correct service   Cons   Client code must have logic to select a service, and this is an overhead because it unnecessarily combines the client with the service.   Server side service discovery relies on the loadbalancer to query the service registry and then route the client request accordingly.   Pros    Client is not responsible for discovery   Con   Need to maintain one more component", 
            "title": "Service Discovery"
        }, 
        {
            "location": "/implementation_details/#service-registration", 
            "text": "There are two possible solutions for service registration: self registration and third party registration.  Self registration (and deregistration) requires the service to register with Consul, using either the Consul HTTP API or DNS API.   Pros   No third party application required   Cons   Application will have to register itself   Third party registration requires another component called a service registrar to register the service. In this case, an application called Registrator can automatically register a service to Consul.  Pros   Automatic, because the application does not have to handle the registration   Cons   One more component dependency", 
            "title": "Service Registration"
        }, 
        {
            "location": "/implementation_details/#td-registry-file-structure", 
            "text": "The TD registry file essentially contains key value pairs that map the TD host to a testdouble. If an entry doesn't exist, it means that the testdouble does not exist. The TD registry file should be updated only for the APIs shown below.  1. POST /testdoubles\n2. PUT /testdoubles\n3. DELETE /testdoubles/{testDoubleName}\n4. DELETE /testdoubles  The existence of a testdouble is determined by whether the testdouble with provided name exists in the lookup file.", 
            "title": "TD Registry File Structure"
        }, 
        {
            "location": "/implementation_details/#embed-mb-inside-of-td", 
            "text": "Cons    Lack of control between TD and MB, because MB is embedded inside of TD.  TD remains stateful  Disposing of TD also disposes of MB   Pros   There is only one registry file and that is the TD registry file.   All HTTP requests will be made to localhost, so there is no need to make changes to any code that makes HTTP requests.", 
            "title": "Embed MB inside of TD"
        }, 
        {
            "location": "/implementation_details/#separate-mb-from-td", 
            "text": "Cons   Code that makes HTTP requests will have to be changed to dynamically make a request to the particular host.  tdctl file have to be changed, because MB is no longer imported. This has a cascading effect because MB and TD must be started separately.  If MB is unavailable, it must be restarted separately from TD.   Requires more nodes (either physical or virtual).  Requires one more environment variable, MB_HOST.   Pros   TD becomes stateless, as all state is now maintained in MB, thus achieving disposability.  Allows for greater control of TD, and with this, implemeting SIGTERM and SIGINT behavior is possible.", 
            "title": "Separate MB from TD"
        }
    ]
}